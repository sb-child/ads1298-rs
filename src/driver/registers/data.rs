use bitfield::bitfield;

/// 9.4.1.3.1 状态字
///
/// 状态字 `[0:23]`
#[derive(Clone, Copy, Debug)]
pub struct DataStatus {
    pub ds1: DataStatus1,
    pub ds2: DataStatus2,
    pub ds3: DataStatus3,
}

bitfield! {
    /// 9.4.1.3.1 状态字
    ///
    /// 状态字 `[0:7]`
    #[derive(Clone, Copy)]
    pub struct DataStatus1(u8);
    impl Debug;
    bool;
    /// 通道 5 正通道导联脱落状态
    ///
    /// 有关 IN5P 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in5p_off, set_in5p_off: 7;
    /// 通道 6 正通道导联脱落状态
    ///
    /// 有关 IN6P 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in6p_off, set_in6p_off: 6;
    /// 通道 7 正通道导联脱落状态
    ///
    /// 有关 IN7P 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in7p_off, set_in7p_off: 5;
    /// 通道 8 正通道导联脱落状态
    ///
    /// 有关 IN8P 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in8p_off, set_in8p_off: 4;
    /// Should be `0`
    pub prefix_3, set_prefix_3: 3;
    /// Should be `0`
    pub prefix_2, set_prefix_2: 2;
    /// Should be `1`
    pub prefix_1, set_prefix_1: 1;
    /// Should be `1`
    pub prefix_0, set_prefix_0: 0;
}

bitfield! {
    /// 9.4.1.3.1 状态字
    ///
    /// 状态字 `[8:15]`
    #[derive(Clone, Copy)]
    pub struct DataStatus2(u8);
    impl Debug;
    bool;
    /// 通道 5 负通道导联脱落状态
    ///
    /// 有关 IN5N 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in5n_off, set_in5n_off: 7;
    /// 通道 6 负通道导联脱落状态
    ///
    /// 有关 IN6N 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in6n_off, set_in6n_off: 6;
    /// 通道 7 负通道导联脱落状态
    ///
    /// 有关 IN7N 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in7n_off, set_in7n_off: 5;
    /// 通道 8 负通道导联脱落状态
    ///
    /// 有关 IN8N 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in8n_off, set_in8n_off: 4;
    /// 通道 1 正通道导联脱落状态
    ///
    /// 有关 IN1P 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in1p_off, set_in1p_off: 3;
    /// 通道 2 正通道导联脱落状态
    ///
    /// 有关 IN2P 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in2p_off, set_in2p_off: 2;
    /// 通道 3 正通道导联脱落状态
    ///
    /// 有关 IN3P 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in3p_off, set_in3p_off: 1;
    /// 通道 4 正通道导联脱落状态
    ///
    /// 有关 IN4P 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in4p_off, set_in4p_off: 0;
}

bitfield! {
    /// 9.4.1.3.1 状态字
    ///
    /// 状态字 `[16:23]`
    #[derive(Clone, Copy)]
    pub struct DataStatus3(u8);
    impl Debug;
    bool;
    /// GPIO 数据 `[1]`
    ///
    /// 这些位用于从 GPIO 端口读取数据以及向其中写入数据。
    /// 在读取寄存器时，返回的数据对应于 GPIO 外部引脚的状态，无
    /// 论它们是编程为输入还是输出都是如此。作为输出时，对 GPIOD
    /// 进行写入可设置输出值。作为输入时，对 GPIOD 进行写入无效。
    /// GPIO 在某些呼吸模式下不可用。
    pub gpiod_1, set_gpiod_1: 7;
    /// GPIO 数据 `[2]`
    ///
    /// 这些位用于从 GPIO 端口读取数据以及向其中写入数据。
    /// 在读取寄存器时，返回的数据对应于 GPIO 外部引脚的状态，无
    /// 论它们是编程为输入还是输出都是如此。作为输出时，对 GPIOD
    /// 进行写入可设置输出值。作为输入时，对 GPIOD 进行写入无效。
    /// GPIO 在某些呼吸模式下不可用。
    pub gpiod_2, set_gpiod_2: 6;
    /// GPIO 数据 `[3]`
    ///
    /// 这些位用于从 GPIO 端口读取数据以及向其中写入数据。
    /// 在读取寄存器时，返回的数据对应于 GPIO 外部引脚的状态，无
    /// 论它们是编程为输入还是输出都是如此。作为输出时，对 GPIOD
    /// 进行写入可设置输出值。作为输入时，对 GPIOD 进行写入无效。
    /// GPIO 在某些呼吸模式下不可用。
    pub gpiod_3, set_gpiod_3: 5;
    /// GPIO 数据 `[4]`
    ///
    /// 这些位用于从 GPIO 端口读取数据以及向其中写入数据。
    /// 在读取寄存器时，返回的数据对应于 GPIO 外部引脚的状态，无
    /// 论它们是编程为输入还是输出都是如此。作为输出时，对 GPIOD
    /// 进行写入可设置输出值。作为输入时，对 GPIOD 进行写入无效。
    /// GPIO 在某些呼吸模式下不可用。
    pub gpiod_4, set_gpiod_4: 4;
    /// 通道 1 负通道导联脱落状态
    ///
    /// 有关 IN1N 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in1n_off, set_in1n_off: 3;
    /// 通道 2 负通道导联脱落状态
    ///
    /// 有关 IN2N 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in2n_off, set_in2n_off: 2;
    /// 通道 3 负通道导联脱落状态
    ///
    /// 有关 IN3N 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in3n_off, set_in3n_off: 1;
    /// 通道 4 负通道导联脱落状态
    ///
    /// 有关 IN4N 电极是打开还是关闭的状态
    ///
    /// 0：电极打开, 1：电极关闭
    pub in4n_off, set_in4n_off: 0;
}

bitfield! {
    /// ID 控制寄存器 地址 = `00h` 复位 = `xxh`
    pub struct IdReg(u8);
    impl Debug;
    bool;
    /// 器件 ID `[7]` `R` 复位 = `X`
    dev_id_7, set_dev_id_7: 7;
    /// 器件 ID `[6]` `R` 复位 = `X`
    dev_id_6, set_dev_id_6: 6;
    /// 器件 ID `[5]` `R` 复位 = `X`
    dev_id_5, set_dev_id_5: 5;
    /// 保留 `[4]` `R` 复位 = `1`
    rev_4, set_rev_4: 4;
    /// 保留 `[3]` `R` 复位 = `0`
    rev_3, set_rev_3: 3;
    /// 通道 ID `[2]` `R` 复位 = `X`
    dev_id_2, set_dev_id_2: 2;
    /// 通道 ID `[1]` `R` 复位 = `X`
    dev_id_1, set_dev_id_1: 1;
    /// 通道 ID `[0]` `R` 复位 = `X`
    dev_id_0, set_dev_id_0: 0;
}

bitfield! {
    /// 配置寄存器 1 地址 = `01h` 复位 = `06h`
    pub struct Config1Reg(u8);
    impl Debug;
    bool; u8;
    /// 高分辨率或低功耗模式 `[7]` `R/W` 复位 = `0`
    ///
    /// 该位决定器件是以低功耗模式运行还是以高分辨率模式运行。
    ///
    /// - 0 = LP 模式
    /// - 1 = HR 模式
    hr, set_hr: 7;
    /// 菊花链或多读回模式 `[6]` `R/W` 复位 = `0`
    ///
    /// 该位决定启用哪种模式。
    ///
    /// - 0 = 菊花链模式
    /// - 1 = 多读回模式
    daisy_en, set_daisy_en: 6;
    /// CLK 连接 `[5]` `R/W` 复位 = `0`
    ///
    /// 该位决定当 CLKSEL 引脚 = 1 时内部振荡器信号是否连接到 CLK
    /// 引脚。
    ///
    /// - 0 = 禁用振荡器时钟输出
    /// - 1 = 启用振荡器时钟输出
    clk_en, set_clk_en: 5;
    /// 保留 `[4]` `R/W` 复位 = `0`
    rev_4, set_rev_4: 4;
    /// 保留 `[3]` `R/W` 复位 = `0`
    rev_3, set_rev_3: 3;
    /// 输出数据速率 `[5]` `R/W` 复位 = `110b = 6`
    ///
    /// 对于高分辨率模式，fMOD = fCLK/4。低于低功耗模式，fMOD =
    /// fCLK/8。
    ///
    /// 这些位决定器件的输出数据速率。
    ///
    /// - 000：fMOD/16（HR 模式：32kSPS，LP 模式：16kSPS）
    /// - 001：fMOD/32（HR 模式：16kSPS，LP 模式：8kSPS）
    /// - 010：fMOD/64（HR 模式：8kSPS，LP 模式：4kSPS）
    /// - 011：fMOD/128（HR 模式：4kSPS，LP 模式：2kSPS）
    /// - 100：fMOD/256（HR 模式：2kSPS，LP 模式：1kSPS）
    /// - 101：fMOD/512（HR 模式：1kSPS，LP 模式：500SPS）
    /// - 110：fMOD/1024（HR 模式：500SPS，LP 模式：250SPS）
    /// - 111：保留（不使用）
    dr, set_dr: 2, 0;
}

bitfield! {
    /// 配置寄存器 2 地址 = `02h` 复位 = `40h`
    pub struct Config2Reg(u8);
    impl Debug;
    bool; u8;
    /// 保留 `[7]` `R/W` 复位 = `0`
    ///
    /// 始终写入 `0`
    rev_7, set_rev_7: 7;
    /// 保留 `[6]` `R/W` 复位 = `1`
    ///
    /// 始终写入 `0`
    rev_6, set_rev_6: 6;
    /// WCT 斩波方案 `[5]` `R/W` 复位 = `0`
    ///
    /// 该位决定 WCT 放大器的斩波频率是可变还是固定的。
    ///
    /// - 0 = 斩波频率可变，请参阅 Table 7
    /// - 1 = 斩波频率恒定保持在 fMOD/16
    wct_chop, set_wct_chop: 5;
    /// 测试源 `[4]` `R/W` 复位 = `0`
    ///
    /// 该位决定测试信号源。
    ///
    /// - 0 = 从外部驱动测试信号
    /// - 1 = 在内部生成测试信号
    int_test, set_int_test: 4;
    /// 保留 `[3]` `R/W` 复位 = `0`
    rev_3, set_rev_3: 3;
    /// 测试信号振幅 `[2]` `R/W` 复位 = `0`
    ///
    /// 这些位决定校准信号振幅。
    ///
    /// - 0 = 1 × –(VREFP – VREFN)/2400V
    /// - 1 = 2 × –(VREFP – VREFN)/2400V
    test_amp, set_test_amp: 2;
    /// 测试信号频率 `[1:0]` `R/W` 复位 = `0`
    ///
    /// 这些位决定校准信号频率。
    ///
    /// - 00 = 以 fCLK/2^21 的频率发送脉冲信号
    /// - 01 = 以 fCLK/2^20 的频率发送脉冲信号
    /// - 10 = 未使用
    /// - 11 = 直流
    test_freq, set_test_freq: 1, 0;
}

bitfield! {
    /// 配置寄存器 3 地址 = `03h` 复位 = `40h`
    pub struct Config3Reg(u8);
    impl Debug;
    bool;
    /// 关断基准缓冲器 `[7]` `R/W` 复位 = `0`
    ///
    /// 该位决定关断基准缓冲器状态。
    ///
    /// - 0 = 关断内部基准缓冲器
    /// - 1 = 启用内部基准缓冲器
    pd_refbuf, set_pd_refbuf: 7;
    /// 保留 `[6]` `R/W` 复位 = `1`
    ///
    /// 始终写入 `1`
    rev_6, set_rev_6: 6;
    /// 基准电压 `[5]` `R/W` 复位 = `0`
    ///
    /// 该位决定基准电压 VREFP。
    ///
    /// - 0 = VREFP 设置为 2.4V
    /// - 1 = VREFP 设置为 4V（仅与 5V 模拟电源配合使用）
    vref_4v, set_vref_4v: 5;
    /// RLD 测量 `[4]` `R/W` 复位 = `0`
    ///
    /// 该位启用 RLD 测量。可以使用任何通道测量 RLD 信号。
    ///
    /// - 0 = 开路
    /// - 1 = RLD_IN 信号路由至具有 MUX_Setting 010 (VREF) 的通道
    rld_meas, set_rld_meas: 4;
    /// RLDREF 信号 `[3]` `R/W` 复位 = `0`
    ///
    /// 该位决定 RLDREF 信号源。
    ///
    /// - 0 = 从外部馈送 RLDREF 信号
    /// - 1 = 在内部生成 RLDREF 信号 (AVDD – AVSS)/2
    rldref_int, set_rldref_int: 3;
    /// RLD 缓冲器电源 `[2]` `R/W` 复位 = `0`
    ///
    /// 该位决定 RLD 缓冲器电源状态。
    ///
    /// - 0 = RLD 缓冲器断电
    /// - 1 = 启用 RLD 缓冲器
    pd_rld, set_pd_rld: 2;
    /// RLD 感应功能 `[1]` `R/W` 复位 = `0`
    ///
    /// 该位启用 RLD 感应功能。
    ///
    /// - 0 = 禁用 RLD 感应
    /// - 1 = 启用 RLD 感应
    rld_loff_sens, set_rld_loff_sens: 1;
    /// RLD 导联脱落状态 `[0]` `R` 复位 = `0`
    ///
    /// 该位决定 RLD 状态。
    ///
    /// - 0 = RLD 已连接
    /// - 1 = RLD 未连接
    rld_stat, set_rld_stat: 0;
}

bitfield! {
    /// 导联脱落控制寄存器 地址 = `04h` 复位 = `00h`
    pub struct LOffReg(u8);
    impl Debug;
    bool; u8;
    /// 导联脱落比较器阈值 `[7:5]` `R/W` 复位 = `0h`
    ///
    /// 比较器正极侧
    ///
    /// - 000 = 95%
    /// - 001 = 92.5%
    /// - 010 = 90%
    /// - 011 = 87.5%
    /// - 100 = 85%
    /// - 101 = 80%
    /// - 110 = 75%
    /// - 111 = 70%
    ///
    /// 比较器负极侧
    ///
    /// - 000 = 5%
    /// - 001 = 7.5%
    /// - 010 = 10%
    /// - 011 = 12.5%
    /// - 100 = 15%
    /// - 101 = 20%
    /// - 110 = 25%
    /// - 111 = 30%
    comp_th, set_comp_th: 7, 5;
    /// 导联脱落检测模式 `[4]` `R/W` 复位 = `0h`
    ///
    /// 该位决定导联脱落检测模式。
    ///
    /// - 0 = 电流源模式导联脱落
    /// - 1 = 上拉或下拉电阻器模式导联脱落
    vlead_off_en, set_vlead_off_en: 4;
    /// 导联脱落电流幅度 `[3:2]` `R/W` 复位 = `0h`
    ///
    /// 这些位决定当前导联脱落模式的电流幅度。
    ///
    /// - 00 = 6nA
    /// - 01 = 12nA
    /// - 10 = 18nA
    /// - 11 = 24nA
    ilead_off, set_ilead_off: 3, 2;
    /// 导联脱落频率 `[1:0]` `R/W` 复位 = `0h`
    ///
    /// 这些位决定每个通道的导联脱落检测的频率。
    ///
    /// - 00 = 当 LOFF_SENSP 或 LOFF_SENSN 寄存器的任何位打开时，确保 FLEAD[1:0] 设置为 01 或 11
    /// - 01 = 以 FDR/4 的频率执行交流导联脱落检测
    /// - 10 = 不使用
    /// - 11 = 直流导联脱落检测打开
    flead_off, set_flead_off: 1, 0;
}

bitfield! {
    /// 通道设置 地址 = `05h` 复位 = `00h`
    pub struct ChSetReg(u8);
    impl Debug;
    bool; u8;
    /// 断电 `[7]` `R/W` 复位 = `0`
    ///
    /// 该位决定相应通道的通道电源模式。
    ///
    /// - 0 = 正常运行
    /// - 1 = 通道断电
    ///
    /// 在关闭某个通道的电源时，TI 建议通过设置 CHnSET 寄存器的相应
    /// MUXn`[2:0]` = 001，将该通道设置为输入短路。
    pd, set_pd: 7;
    /// PGA 增益 `[6:4]` `R/W` 复位 = `0`
    ///
    /// 这些位决定 PGA 增益设置。
    ///
    /// - 000 = 6
    /// - 001 = 1
    /// - 010 = 2
    /// - 011 = 3
    /// - 100 = 4
    /// - 101 = 8
    /// - 110 = 12
    gain, set_gain: 6, 5, 4;
    /// 保留 `[3]` `R/W` 复位 = `0`
    ///
    /// 始终写入 0
    rev_3, set_rev_3: 3;
    /// 通道输入 `[2:0]` `R/W` 复位 = `0`
    ///
    /// 这些位决定通道输入选择。
    ///
    /// - 000 = 正常电极输入
    /// - 001 = 输入短路（对于偏移或噪声测量）
    /// - 010 = 与 RLD_MEAS 位结合使用，以进行 RLD 测量。有关更多详细信息，请参阅
    /// ECG 专用功能 部分的右腿驱动 (RLD) 直流偏置电流 小节。
    /// - 011 = MVDD，用于电源测量
    /// - 100 = 温度传感器
    /// - 101 = 测试信号
    /// - 110 = RLD_DRP（正电极是驱动器）
    /// - 111 = RLD_DRN（负电极是驱动器）
    mux, set_mux: 2, 0;
}

bitfield! {
    /// RLD 正信号导出寄存器 地址 = `0Dh` 复位 = `00h`
    pub struct Rld_SensPReg(u8);
    impl Debug;
    bool; u8;
    /// 将通道 8 正信号路由到 RLD 导出中 `[7]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld8p, set_rld8p: 7;
    /// 将通道 7 正信号路由到 RLD 导出中 `[6]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld7p, set_rld7p: 6;
    /// 将通道 6 正信号路由到 RLD 导出中 `[5]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld6p, set_rld6p: 5;
    /// 将通道 5 正信号路由到 RLD 导出中 `[4]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld5p, set_rld5p: 4;
    /// 将通道 4 正信号路由到 RLD 导出中 `[3]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld4p, set_rld4p: 3;
    /// 将通道 3 正信号路由到 RLD 导出中 `[2]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld3p, set_rld3p: 2;
    /// 将通道 2 正信号路由到 RLD 通道中 `[1]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld2p, set_rld2p: 1;
    /// 将通道 1 正信号路由到 RLD 通道中 `[0]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld1p, set_rld1p: 0;
}

bitfield! {
    /// RLD 负信号导出寄存器 地址 = `0Eh` 复位 = `00h`
    pub struct Rld_SensNReg(u8);
    impl Debug;
    bool; u8;
    /// 将通道 8 负信号路由到 RLD 导出中 `[7]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld8n, set_rld8n: 7;
    /// 将通道 7 负信号路由到 RLD 导出中 `[6]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld7n, set_rld7n: 6;
    /// 将通道 6 负信号路由到 RLD 导出中 `[5]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld6n, set_rld6n: 5;
    /// 将通道 5 负信号路由到 RLD 导出中 `[4]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld5n, set_rld5n: 4;
    /// 将通道 4 负信号路由到 RLD 导出中 `[3]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld4n, set_rld4n: 3;
    /// 将通道 3 负信号路由到 RLD 导出中 `[2]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld3n, set_rld3n: 2;
    /// 将通道 2 负信号路由到 RLD 通道中 `[1]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld2n, set_rld2n: 1;
    /// 将通道 1 负信号路由到 RLD 通道中 `[0]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    rld1n, set_rld1n: 0;
}

bitfield! {
    /// 正信号导联脱落检测寄存器 地址 = `0Fh` 复位 = `00h`
    pub struct LOffSensPReg(u8);
    impl Debug;
    bool; u8;
    /// 启用 IN8P 上的导联脱落检测 `[7]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff8p, set_loff8p: 7;
    /// 启用 IN7P 上的导联脱落检测 `[6]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff7p, set_loff7p: 6;
    /// 启用 IN6P 上的导联脱落检测 `[5]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff6p, set_loff6p: 5;
    /// 启用 IN5P 上的导联脱落检测 `[4]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff5p, set_loff5p: 4;
    /// 启用 IN4P 上的导联脱落检测 `[3]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff4p, set_loff4p: 3;
    /// 启用 IN3P 上的导联脱落检测 `[2]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff3p, set_loff3p: 2;
    /// 启用 IN2P 上的导联脱落检测 `[1]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff2p, set_loff2p: 1;
    /// 启用 IN1P 上的导联脱落检测 `[0]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff1p, set_loff1p: 0;
}

bitfield! {
    /// 负信号导联脱落检测寄存器 地址 = `10h` 复位 = `00h`
    pub struct LOffSensNReg(u8);
    impl Debug;
    bool; u8;
    /// 启用 IN8N 上的导联脱落检测 `[7]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff8n, set_loff8n: 7;
    /// 启用 IN7N 上的导联脱落检测 `[6]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff7n, set_loff7n: 6;
    /// 启用 IN6N 上的导联脱落检测 `[5]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff6n, set_loff6n: 5;
    /// 启用 IN5N 上的导联脱落检测 `[4]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff5n, set_loff5n: 4;
    /// 启用 IN4N 上的导联脱落检测 `[3]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff4n, set_loff4n: 3;
    /// 启用 IN3N 上的导联脱落检测 `[2]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff3n, set_loff3n: 2;
    /// 启用 IN2N 上的导联脱落检测 `[1]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff2n, set_loff2n: 1;
    /// 启用 IN1N 上的导联脱落检测 `[0]` `R/W` 复位 = `0`
    ///
    /// - 0：禁用
    /// - 1：启用
    loff1n, set_loff1n: 0;
}
